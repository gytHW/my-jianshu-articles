>指针和引用是C/C++中两个非常重要的概念，这两天看了下“指针”和“引用”的`wikipedia`词条，对他们有了一些新的认识，这里记录下个人的理解和想法，也可以引申到其他语言。

#指针
我们都知道`*p`表示指针
但其实这个`*`符号是有两种意义的，两种不同的意义。
1.  在定义变量的时候，*表示这是一个指针，它只是一个___标识符___，表示这是一个指针变量
2. 在其他时候，非定义语句中，*是___解引用运算符___ ——用来解出变量指向的那个地址的值
`eg.`
 ```C
    int a = 10;
    int *p = &a; // 这里*只是一个标识符，标识p是一个“指针变量”，p的值为a的地址（&a为取地址，注意c里面没有“引用”的概念）
    int function test(*p)
    {
    }
    test(&a);
	//这里的*p是解引用运算符，表示p这个“指针变量”指向的值。
```
综上，注意`*p`中的`*`是解引用运算符，表示p这个指针变量所指向的值，比如`int *p=&a`，那这个`*p`就是一个普通的整型变量，跟普通的整型变量没什么区别，一样使用方式。也就是说看到`*p`的时候就当做一个普通变量一样使用就行了。

“指针变量”这个词指的是 `p`，指针是一个变量，变量值为一个内存地址，`*p`解引用取出这个内存地址上保存的值。

* 为什么要使用指针？
>函数的参数传递都是__值传递__，也就是会把变量复制一份传递，这样如果数据比较大，效率很低，而使用指针传递的话，只需要复制一个内存地址传递（指针也是一个值），效率很高很快，可以节省时间和空间。
***
#引用
所谓引用的概念，在 `C`里面是没有的，是`C++`提出的概念，因为指针不安全，容易错误使用，产生内存问题。
	java不支持使用指针，c++支持有限的使用指针（为了保持对c的兼容）
	他们提供了引用用来代替指针的功能。

注意：在C中没有引用的概念，&在C里面只表示取地址。
	
>所谓引用，可以理解为变量的__“别名”__
指针是最简单的引用。
	
引用的用法类似指针：
`eg.`
```C++
    int a = 10;
    int &b = a; //这里b就是变量a的一个引用，相当于a的别名。
    //指针和引用都是对变量的，无法对常量引用，而虽然可以对常量建立指针不过没什么意义。
```

引用与指针的区别------`wikipedia`
对于同时支持引用与指针的C/C++，两类数据型的区别有：
* 指针可以重新赋值，而引用在初始化绑定后就不能再绑定到其他对象。
* 指针对象有它自己的内存地址与内存长度，而引用与它指向的对象具有相同的内存地址、内存长度。因此，可以把引用看作是被指向对象的另一个名字。
* 指针可以指向另一指针，因此允许多层的指针间址（indirection）；而引用只允许到对象的一层间址，不允许“引用的引用”。
* 指针可以直接赋值为NULL，引用不能。当然，可以费劲办法把引用绑定到内存的NULL上，但这并不实用。
* 指针可以在数组上遍历（iterate），引用不能。
* 指针需要用运算符`*`来解引用（dereference）以访问它所指向的内存的内容；引用需要显式的解引用。指向类/结构的指针访问成员变量/成员函数需要用运算符->而引用使用运算符.来访问成员。
* 指针是一个变量，保存了内存地址；而C/C++标准都没有明说引用是如何实现的。实际上，几乎所有C/C++编译器把引用作为一个隐式的指针来实现。
* 指针可以成为数组的成员类型，即指针数组；但引用不可以作为数组的成员类型，即不存在“引用数组”。
* const引用可以绑定到临时对象；而指针不能（例如，int *y = 12;编译出错）。按照C++11语法，const左值引用可以绑定到一切对象，包括const左值对象，非const左值对象，const临时对象，非const临时对象；右值引用当然可以绑定到临时对象。
***
###### 参考：
[维基百科 - 指针](https://zh.wikipedia.org/wiki/%E6%8C%87%E9%92%88)
[维基百科 - 引用](https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7)
